{"version":3,"sources":["file:///Volumes/%E5%9B%BA%E6%80%81/project/node_modules/crypto-es/lib/mode-ctr.js"],"names":["CTR","BlockCipherMode","Encryptor","processBlock","words","offset","_words","cipher","_cipher","blockSize","iv","_iv","counter","_counter","slice","undefined","keystream","encryptBlock","i","Decryptor"],"mappings":";;;uBAOaA,G;;;;;;AAHXC,MAAAA,e,gBAAAA,e;;;AAJF;AACA;AACA;qBAKaD,G,GAAN,MAAMA,GAAN,SAAkBC,eAAlB,CAAkC,E;;AAEzCD,MAAAA,GAAG,CAACE,SAAJ,GAAgB,cAAcF,GAAd,CAAkB;AAChCG,QAAAA,YAAY,CAACC,KAAD,EAAQC,MAAR,EAAgB;AAC1B,gBAAMC,MAAM,GAAGF,KAAf,CAD0B,CAG1B;;AACA,gBAAMG,MAAM,GAAG,KAAKC,OAApB;AACA,gBAAM;AAAEC,YAAAA;AAAF,cAAgBF,MAAtB;AACA,gBAAMG,EAAE,GAAG,KAAKC,GAAhB;AACA,cAAIC,OAAO,GAAG,KAAKC,QAAnB,CAP0B,CAS1B;;AACA,cAAIH,EAAJ,EAAQ;AACN,iBAAKG,QAAL,GAAgBH,EAAE,CAACI,KAAH,CAAS,CAAT,CAAhB;AACAF,YAAAA,OAAO,GAAG,KAAKC,QAAf,CAFM,CAIN;;AACA,iBAAKF,GAAL,GAAWI,SAAX;AACD;;AACD,gBAAMC,SAAS,GAAGJ,OAAO,CAACE,KAAR,CAAc,CAAd,CAAlB;AACAP,UAAAA,MAAM,CAACU,YAAP,CAAoBD,SAApB,EAA+B,CAA/B,EAlB0B,CAoB1B;;AACAJ,UAAAA,OAAO,CAACH,SAAS,GAAG,CAAb,CAAP,GAA0BG,OAAO,CAACH,SAAS,GAAG,CAAb,CAAP,GAAyB,CAA1B,GAA+B,CAAxD,CArB0B,CAuB1B;;AACA,eAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,SAApB,EAA+BS,CAAC,IAAI,CAApC,EAAuC;AACrCZ,YAAAA,MAAM,CAACD,MAAM,GAAGa,CAAV,CAAN,IAAsBF,SAAS,CAACE,CAAD,CAA/B;AACD;AACF;;AA5B+B,OAAlC;AA8BAlB,MAAAA,GAAG,CAACmB,SAAJ,GAAgBnB,GAAG,CAACE,SAApB","sourcesContent":["/**\r\n * Counter block mode.\r\n */\r\nimport {\r\n  BlockCipherMode,\r\n} from './cipher-core.js';\r\n\r\nexport class CTR extends BlockCipherMode {\r\n}\r\nCTR.Encryptor = class extends CTR {\r\n  processBlock(words, offset) {\r\n    const _words = words;\r\n\r\n    // Shortcuts\r\n    const cipher = this._cipher;\r\n    const { blockSize } = cipher;\r\n    const iv = this._iv;\r\n    let counter = this._counter;\r\n\r\n    // Generate keystream\r\n    if (iv) {\r\n      this._counter = iv.slice(0);\r\n      counter = this._counter;\r\n\r\n      // Remove IV for subsequent blocks\r\n      this._iv = undefined;\r\n    }\r\n    const keystream = counter.slice(0);\r\n    cipher.encryptBlock(keystream, 0);\r\n\r\n    // Increment counter\r\n    counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;\r\n\r\n    // Encrypt\r\n    for (let i = 0; i < blockSize; i += 1) {\r\n      _words[offset + i] ^= keystream[i];\r\n    }\r\n  }\r\n};\r\nCTR.Decryptor = CTR.Encryptor;\r\n"]}