{"version":3,"sources":["file:///Volumes/%E5%9B%BA%E6%80%81/ccProject/extensions/oops-plugin-framework/assets/libs/model-view/JsonOb.ts"],"names":["JsonOb","OP","Object","prototype","types","obj","array","OAM","constructor","callback","_callback","toString","call","console","error","observe","path","overrideArrayProto","keys","forEach","key","self","oldVal","pathArray","slice","push","defineProperty","get","set","newVal","originalProto","Array","overrideProto","create","result","method","value","apply","arguments"],"mappings":"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","sourcesContent":["/*\r\n * @Author: dgflash\r\n * @Date: 2022-09-01 18:00:28\r\n * @LastEditors: dgflash\r\n * @LastEditTime: 2022-09-06 17:18:05\r\n */\r\n\r\n/**\r\n * 实现动态绑定的核心部分，\r\n * 每次修改属性值，都会调用对应函数，并且获取值的路径\r\n */\r\nconst OP = Object.prototype;\r\nconst types = {\r\n    obj: '[object Object]',\r\n    array: '[object Array]'\r\n}\r\nconst OAM = ['push', 'pop', 'shift', 'unshift', 'sort', 'reverse', 'splice'];\r\n\r\n/**\r\n * 实现属性拦截的类\r\n */\r\nexport class JsonOb<T> {\r\n    constructor(obj: T, callback: (newVal: any, oldVal: any, pathArray: string[]) => void) {\r\n        if (OP.toString.call(obj) !== types.obj && OP.toString.call(obj) !== types.array) {\r\n            console.error('请传入一个对象或数组');\r\n        }\r\n        this._callback = callback;\r\n        this.observe(obj);\r\n    }\r\n\r\n    private _callback;\r\n\r\n    /**对象属性劫持 */\r\n    private observe<T>(obj: T, path?: any) {\r\n        if (OP.toString.call(obj) === types.array) {\r\n            this.overrideArrayProto(obj, path);\r\n        }\r\n\r\n        // @ts-ignore  注：避免API生成工具报错\r\n        Object.keys(obj).forEach((key) => {\r\n            let self = this;\r\n            // @ts-ignore\r\n            let oldVal = obj[key];\r\n            let pathArray = path && path.slice();\r\n            if (pathArray) {\r\n                pathArray.push(key);\r\n            }\r\n            else {\r\n                pathArray = [key];\r\n            }\r\n            Object.defineProperty(obj, key, {\r\n                get: function () {\r\n                    return oldVal;\r\n                },\r\n                set: function (newVal) {\r\n                    //cc.log(newVal);\r\n                    if (oldVal !== newVal) {\r\n                        if (OP.toString.call(newVal) === '[object Object]') {\r\n                            self.observe(newVal, pathArray);\r\n                        }\r\n                        self._callback(newVal, oldVal, pathArray);\r\n                        oldVal = newVal;\r\n                    }\r\n                }\r\n            })\r\n\r\n            // @ts-ignore\r\n            if (OP.toString.call(obj[key]) === types.obj || OP.toString.call(obj[key]) === types.array) {\r\n                // @ts-ignore\r\n                this.observe(obj[key], pathArray);\r\n            }\r\n        }, this)\r\n    }\r\n\r\n    /**\r\n     * 对数组类型进行动态绑定\r\n     * @param array \r\n     * @param path \r\n     */\r\n    private overrideArrayProto(array: any, path: any) {\r\n        // 保存原始 Array 原型  \r\n        var originalProto = Array.prototype;\r\n        // 通过 Object.create 方法创建一个对象，该对象的原型是Array.prototype  \r\n        var overrideProto = Object.create(Array.prototype);\r\n        var self = this;\r\n        var result;\r\n\r\n        // 遍历要重写的数组方法  \r\n        OAM.forEach((method: any) => {\r\n            Object.defineProperty(overrideProto, method, {\r\n                value: function () {\r\n                    var oldVal = this.slice();\r\n                    //调用原始原型上的方法  \r\n                    result = originalProto[method].apply(this, arguments);\r\n                    //继续监听新数组  \r\n                    self.observe(this, path);\r\n                    self._callback(this, oldVal, path);\r\n                    return result;\r\n                }\r\n            })\r\n        });\r\n\r\n        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto  \r\n        array['__proto__'] = overrideProto;\r\n    }\r\n}"]}