{"version":3,"sources":["file:///Volumes/SSD%201/ccProject/node_modules/crypto-es/lib/enc-base64.js"],"names":["WordArray","parseLoop","base64Str","base64StrLength","reverseMap","words","nBytes","i","bits1","charCodeAt","bits2","bitsCombined","create","Base64","stringify","wordArray","sigBytes","map","_map","clamp","base64Chars","byte1","byte2","byte3","triplet","j","push","charAt","paddingChar","length","join","parse","_reverseMap","paddingIndex","indexOf"],"mappings":"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","sourcesContent":["import {\r\n  WordArray,\r\n} from './core.js';\r\n\r\nconst parseLoop = (base64Str, base64StrLength, reverseMap) => {\r\n  const words = [];\r\n  let nBytes = 0;\r\n  for (let i = 0; i < base64StrLength; i += 1) {\r\n    if (i % 4) {\r\n      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\r\n      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\r\n      const bitsCombined = bits1 | bits2;\r\n      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\r\n      nBytes += 1;\r\n    }\r\n  }\r\n  return WordArray.create(words, nBytes);\r\n};\r\n\r\n/**\r\n * Base64 encoding strategy.\r\n */\r\nexport const Base64 = {\r\n  /**\r\n   * Converts a word array to a Base64 string.\r\n   *\r\n   * @param {WordArray} wordArray The word array.\r\n   *\r\n   * @return {string} The Base64 string.\r\n   *\r\n   * @static\r\n   *\r\n   * @example\r\n   *\r\n   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);\r\n   */\r\n  stringify(wordArray) {\r\n    // Shortcuts\r\n    const { words, sigBytes } = wordArray;\r\n    const map = this._map;\r\n\r\n    // Clamp excess bits\r\n    wordArray.clamp();\r\n\r\n    // Convert\r\n    const base64Chars = [];\r\n    for (let i = 0; i < sigBytes; i += 3) {\r\n      const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\r\n      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\r\n\r\n      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\r\n\r\n      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j += 1) {\r\n        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\r\n      }\r\n    }\r\n\r\n    // Add padding\r\n    const paddingChar = map.charAt(64);\r\n    if (paddingChar) {\r\n      while (base64Chars.length % 4) {\r\n        base64Chars.push(paddingChar);\r\n      }\r\n    }\r\n\r\n    return base64Chars.join('');\r\n  },\r\n\r\n  /**\r\n   * Converts a Base64 string to a word array.\r\n   *\r\n   * @param {string} base64Str The Base64 string.\r\n   *\r\n   * @return {WordArray} The word array.\r\n   *\r\n   * @static\r\n   *\r\n   * @example\r\n   *\r\n   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);\r\n   */\r\n  parse(base64Str) {\r\n    // Shortcuts\r\n    let base64StrLength = base64Str.length;\r\n    const map = this._map;\r\n    let reverseMap = this._reverseMap;\r\n\r\n    if (!reverseMap) {\r\n      this._reverseMap = [];\r\n      reverseMap = this._reverseMap;\r\n      for (let j = 0; j < map.length; j += 1) {\r\n        reverseMap[map.charCodeAt(j)] = j;\r\n      }\r\n    }\r\n\r\n    // Ignore padding\r\n    const paddingChar = map.charAt(64);\r\n    if (paddingChar) {\r\n      const paddingIndex = base64Str.indexOf(paddingChar);\r\n      if (paddingIndex !== -1) {\r\n        base64StrLength = paddingIndex;\r\n      }\r\n    }\r\n\r\n    // Convert\r\n    return parseLoop(base64Str, base64StrLength, reverseMap);\r\n  },\r\n\r\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\r\n};\r\n"]}